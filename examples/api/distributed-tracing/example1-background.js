/*
 * Copyright 2020 New Relic Corporation. All rights reserved.
 * SPDX-License-Identifier: Apache-2.0
 */

'use strict'

const newrelic = require('newrelic') // eslint-disable-line node/no-extraneous-require

/*
For context on how to use acceptDistributedTraceHeaders and insertDistributedTraceHeaders,
first read "Enable distributed tracing with agent APIs":

https://docs.newrelic.com/docs/distributed-tracing/enable-configure/language-agents-enable-distributed-tracing/

You can use insertDistributedTraceHeaders and acceptDistributedTraceHeaders to
link different transactions together. In this example, a custom web transaction
is linked to a background transaction, for example to instrument tracing of
interactions with resources external to your application.

`insertDistributedTraceHeaders` modifies the headers map that is passed in by adding W3C Trace Context headers and New Relic Distributed Trace headers. The New Relic headers can be disabled with `distributed_tracing.exclude_newrelic_header: true` in the config.

`acceptDistributedTraceHeaders` is used to instrument the called service for inclusion in a distributed trace. It links the spans in a trace by accepting a payload generated by `insertDistributedTraceHeaders` or generated by some other W3C Trace Context compliant tracer. This method accepts the headers of an incoming request, looks for W3C Trace Context headers, and if not found, falls back to New Relic distributed trace headers.
*/

// Give the agent some time to start up.
setTimeout(runTest, 2000)

function runTest() {
  // Start an outer transaction
  newrelic.startWebTransaction('Custom web transaction', function outerHandler() {
    // Call newrelic.getTransaction to retrieve a handle on the current transaction.
    const transactionHandle = newrelic.getTransaction()

    // Generate the payload right before creating the linked transaction.
    const headers = {}
    transactionHandle.insertDistributedTraceHeaders(headers)

    // Start an inner transaction that handles some nested task
    newrelic.startBackgroundTransaction('Background task', function innerHandler() {
      const backgroundHandle = newrelic.getTransaction()
      // Link the outer transaction by accepting its headers as a payload
      // with the inner transaction's handle
      backgroundHandle.acceptDistributedTraceHeaders(headers)
      // End the transactions
      backgroundHandle.end(transactionHandle.end)
    })
  })
}
